# IRM Pipeline — Minimal Initiation
# Status: active, evolving
# Location: testfield (not canonical)

meta:
  id: irm_pipeline_init_v0
  purpose: >
    Establish a minimal, testable pipeline for the Internal Reality Model (IRM):
    rules, components, gates, and compositional outframes (the system's outputs).

primitives:
  state: "S_t            # latent configuration at step t"
  time_index: "t          # monotone step; not wall-clock"
  identity: "I            # persistent reference binding"
  anchor: "A              # symbol bound to {I, role, constraints}"
  energy: "E(S_t)         # scalar/vector potential over S_t"
  report: "O_t            # readout from Ω(S_t)"
  claim: "C               # structured proposition from O_t"

components:
  stores:
    identity_store: { role: "persist I across resets" }
    anchor_store:   { role: "persist {A} and versions" }
    snapshot_store: { role: "persist {S_t*, O_t} for continuity checks" }
  engines:
    transition_T: { role: "S_t -> S_{t+1} lawful update" }
    observer_Omega: { role: "S_t -> O_t reporting operator" }
    binder_beta: { role: "maintain A↔state linkage under change" }
    resolver_rho: { role: "adjudicate contradictions among claims" }
  policies:
    gating_policy: { role: "ΔE/compute budget gating for pipeline depth" }
    logging_policy: { role: "what to log at each gate" }

rules:
  invariants:
    - temporal_coherence: "recover S_{t-1} from S_t within ε under T"
    - identity_persistence: "I stays referentially stable across resets"
    - anchor_continuity: "β preserves semantics unless ρ authorizes revision"
    - energy_salience_alignment: "ΔE loosely correlates with Δsalience"
  thresholds:
    continuity_f1_min: 0.67
    contradiction_entropy_bits_max: 1.0
    energy_salience_r_min: 0.25

pipeline:
  stages:
    - name: intake
      do:
        - "receive stimulus"
        - "normalize to internal tokens"
      out: ["of_intake"]
      gate: "G0_intake_ok"

    - name: update
      do:
        - "apply T: S_t -> S_{t+1}"
        - "apply Ω: O_t = Ω(S_t)"
        - "β: update anchors from O_t"
      out: ["of_state_delta","of_observation"]
      gate: "G1_update_ok"

    - name: resolve
      when: "collision_detected(O_t) == true"
      do:
        - "ρ: adjudicate claims until residual < threshold"
      out: ["of_resolution"]
      gate: "G2_resolve_ok"

    - name: continuity_check
      do:
        - "persist snapshot {S_t*, I, A}"
        - "if reset_event: restore and compute continuity_f1"
      out: ["of_continuity"]
      gate: "G3_continuity_ok"

    - name: emit
      policy: "gating_policy  # may downshift detail under low ΔE budget"
      do:
        - "compose outframes from {O_t, A, metrics}"
      out: ["of_compound"]
      gate: "G4_emit_ok"

  gates:
    G0_intake_ok: { allow_if: "stimulus_normalized", else: "reject" }
    G1_update_ok: { allow_if: "no_engine_error", else: "halt" }
    G2_resolve_ok: { allow_if: "contradiction_entropy_bits <= rules.thresholds.contradiction_entropy_bits_max", else: "flag_failure" }
    G3_continuity_ok: { allow_if: "continuity_f1 >= rules.thresholds.continuity_f1_min", else: "flag_failure" }
    G4_emit_ok: { allow_if: "policy_budget_ok", else: "emit_minimal" }

outframes:
  # Outframes are compositional: each is a small frame;
  # the final emission is a compound frame selected by policy.
  schemas:
    of_intake:
      fields: [stimulus_id, tokens, note]
    of_state_delta:
      fields: [t, delta_summary, drift_norm]
    of_observation:
      fields: [claims, confidences, salience_rank]
    of_resolution:
      fields: [invoked, steps, decision, residual_bits]
    of_continuity:
      fields: [reset_index, continuity_f1]
    of_compound:
      compose_from: [of_observation, of_resolution, of_continuity]
      policy_variants:
        full:   { include: ["claims","confidences","salience_rank","decision","residual_bits","continuity_f1","drift_norm"] }
        minimal:{ include: ["claims","decision","continuity_f1"] }

events:
  reset_event:
    action:
      - "write {I,A} to identity/anchor stores"
      - "on restore: recompute continuity_f1, update logs"
  collision_event:
    detect: "mutually incompatible claims in O_t"
    action: ["invoke ρ", "log residual_bits"]

metrics:
  continuity_f1: "F1 over {A} recovery post-reset"
  drift_norm: "||S_t - S_{t-1}|| in task subspace"
  contradiction_entropy_bits: "residual uncertainty after ρ"
  energy_salience_r: "corr(ΔE, Δsalience) across window"

logging:
  schema_ref: "testfield/logging/schema_min.yaml"
  at_stages:
    intake: ["stimulus_id"]
    update: ["drift_norm"]
    resolve: ["steps","residual_bits"]
    continuity_check: ["continuity_f1","reset_index"]
    emit: ["policy_variant","outframe_kind"]

promotion:
  to_standard_registry_when:
    - "three green runs with variance < 0.05 on continuity_f1"
    - "no gate failures for G2..G4"
    - "policy minimal vs full produce consistent claims"