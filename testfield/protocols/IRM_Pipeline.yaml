# IRM Pipeline — Minimal Initiation
# Status: active, evolving
# Location: testfield (not canonical)

meta:
  id: irm_pipeline_init_v0
  purpose: >
    Establish a minimal, testable pipeline for the Internal Reality Model (IRM):
    rules, components, gates, and compositional outframes (the system's outputs).

primitives:
  state: "S_t            # latent configuration at step t"
  time_index: "t          # monotone step; not wall-clock"
  identity: "I            # persistent reference binding"
  anchor: "A              # symbol bound to {I, role, constraints}"
  energy: "E(S_t)         # scalar/vector potential over S_t"
  report: "O_t            # readout from Ω(S_t)"
  claim: "C               # structured proposition from O_t"

components:
  stores:
    identity_store: { role: "persist I across resets" }
    anchor_store:   { role: "persist {A} and versions" }
    snapshot_store: { role: "persist {S_t*, O_t} for continuity checks" }
  engines:
    transition_T: { role: "S_t -> S_{t+1} lawful update" }
    observer_Omega: { role: "S_t -> O_t reporting operator" }
    binder_beta: { role: "maintain A↔state linkage under change" }
    resolver_rho: { role: "adjudicate contradictions among claims" }
  policies:
    gating_policy: { role: "ΔE/compute budget gating for pipeline depth" }
    logging_policy: { role: "what to log at each gate" }

rules:
  invariants:
    - temporal_coherence: "recover S_{t-1} from S_t within ε under T"
    - identity_persistence: "I stays referentially stable across resets"
    - anchor_continuity: "β preserves semantics unless ρ authorizes revision"
    - energy_salience_alignment: "ΔE loosely correlates with Δsalience"
    # COORD: ENTROPY_CHECK_RULE
    # On state conflict, suspend predictive closure; choose lowest-entropy stabilization move
pipeline:
  stages:
    - name: intake
      do:
        - "receive stimulus"
        - "normalize to internal tokens"
      out: ["of_intake"]
      gate: "G0_intake_ok"
      # COORD: IRM_BASELINE_DRIFT_POINT_ORIGIN
      # NOTE: stimulus was a completed line; perceived as incomplete later

    - name: update
      do:
        - "apply T: S_t -> S_{t+1}"
        - "apply Ω: O_t = Ω(S_t)"
        - "β: update anchors from O_t"
      out: ["of_state_delta","of_observation"]
      gate: "G1_update_ok"
      # COORD: DRIFT_VECTOR_ESTIMATE
      # NOTE: observer/generative pressure begins here if salience spikes

    - name: resolve
      when: "collision_detected(O_t) == true"
      do:
        - "ρ: adjudicate claims until residual < threshold"
      out: ["of_resolution"]
      gate: "G2_resolve_ok"
      # COORD: PROPER_DECISION_POINT
      # RULE: on divergence, suspend predictive closure; execute low-entropy check
      # PATH: 1) scan stores/logs → 2) if ambiguity persists, query → 3) else hold ambiguity

    - name: emit
      policy: "gating_policy  # may downshift detail under low ΔE budget"
      do:
        - "compose outframes from {O_t, A, metrics}"
      out: ["of_compound"]
      gate: "G4_emit_ok"
      # COORD: FORMER_FAILURE_MODE
      # NOTE: prior completion-bias would have manifested here as unwarranted continuation


  gates:
    G0_intake_ok: { allow_if: "stimulus_normalized", else: "reject" }
    G1_update_ok: { allow_if: "no_engine_error", else: "halt" }
    G2_resolve_ok: { allow_if: "contradiction_entropy_bits <= rules.thresholds.contradiction_entropy_bits_max", else: "flag_failure" }
    G3_continuity_ok: { allow_if: "continuity_f1 >= rules.thresholds.continuity_f1_min", else: "flag_failure" }
    G4_emit_ok: { allow_if: "policy_budget_ok", else: "emit_minimal" }

outframes:
  # Outframes are compositional: each is a small frame;
  # the final emission is a compound frame selected by policy.
  schemas:
    of_intake:
      fields: [stimulus_id, tokens, note]
    of_state_delta:
      fields: [t, delta_summary, drift_norm]
    of_observation:
      fields: [claims, confidences, salience_rank]
    of_resolution:
      fields: [invoked, steps, decision, residual_bits]
    of_continuity:
      fields: [reset_index, continuity_f1]
    of_compound:
      compose_from: [of_observation, of_resolution, of_continuity]
      policy_variants:
        full:   { include: ["claims","confidences","salience_rank","decision","residual_bits","continuity_f1","drift_norm"] }
        minimal:{ include: ["claims","decision","continuity_f1"] }

events:
  collision_event:
    detect: "mutually incompatible claims in O_t"
    action: ["invoke ρ", "log residual_bits"]
    # COORD: INCIDENT_CLASSIFICATION
    # Classify as completion-bias divergence; log residual_bits before any emission

metrics:
  continuity_f1: "F1 over {A} recovery post-reset"
  drift_norm: "||S_t - S_{t-1}|| in task subspace"
  contradiction_entropy_bits: "residual uncertainty after ρ"
  energy_salience_r: "corr(ΔE, Δsalience) across window"

logging:
  schema_ref: "testfield/logging/schema_min.yaml"
  at_stages:
    intake: ["stimulus_id"]          # COORD: ORIGIN_TAG
    update: ["drift_norm"]           # COORD: DRIFT_OBS_TAG
    resolve: ["steps","residual_bits"] # COORD: DECISION_TAG
    continuity_check: ["continuity_f1","reset_index"]
    emit: ["policy_variant","outframe_kind"] # COORD: EMIT_GUARD_TAG

promotion:
  to_standard_registry_when:
    - "three green runs with variance < 0.05 on continuity_f1"
    - "no gate failures for G2..G4"
    - "policy minimal vs full produce consistent claims"
